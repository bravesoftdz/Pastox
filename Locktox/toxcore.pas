unit ToxCore;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, ctypes;

const
  LIBTOXCORE = {$IFDEF Unix}'libtoxcore.so'{$ENDIF};

type
  TTox = Pointer;

const
 {*****************************************************************************
  *
  * :: Numeric constants
  *
  *****************************************************************************}

  {**
   * The size of a Tox Public Key in bytes.
   *}
  TOX_PUBLIC_KEY_SIZE                = 32;

  {**
   * The size of a Tox Secret Key in bytes.
   *}
  TOX_SECRET_KEY_SIZE                = 32;

  {**
   * The size of a Tox address in bytes. Tox addresses are in the format
   * [Public Key (TOX_PUBLIC_KEY_SIZE bytes)][nospam (4 bytes)][checksum (2 bytes)].
   *
   * The checksum is computed over the Public Key and the nospam value. The first
   * byte is an XOR of all the even bytes (0, 2, 4, ...), the second byte is an
   * XOR of all the odd bytes (1, 3, 5, ...) of the Public Key and nospam.
   *}
  TOX_ADDRESS_SIZE                     = (TOX_PUBLIC_KEY_SIZE +
                                         SizeOf(cuint32) + SizeOf(cuint16));
  {**
   * Maximum length of a nickname in bytes.
   *}
  TOX_MAX_NAME_LENGTH                  = 128;

  {**
   * Maximum length of a status message in bytes.
   *}
  TOX_MAX_STATUS_MESSAGE_LENGTH        = 1007;

  {**
   * Maximum length of a friend request message in bytes.
   *}
  TOX_MAX_FRIEND_REQUEST_LENGTH        = 1016;

  {**
   * Maximum length of a single message after which it should be split.
   *}
  TOX_MAX_MESSAGE_LENGTH               = 1372;

  {**
   * Maximum size of custom packets. TODO: should be LENGTH?
   *}
  TOX_MAX_CUSTOM_PACKET_SIZE           = 1373;

  {**
   * The number of bytes in a hash generated by tox_hash.
   *}
  TOX_HASH_LENGTH                      = 32;

  {**
   * The number of bytes in a file id.
   *}
  TOX_FILE_ID_LENGTH                   = 32;

  {**
   * Maximum file name length for file transfers.
   *}
  TOX_MAX_FILENAME_LENGTH              = 255;

type
  {****************************************************************************
   *
   * :: Global enumerations
   *
   ****************************************************************************}

  {**
   * Represents the possible statuses a client can have.
   *}
  TOX_USER_STATUS =
  (
      {**
       * User is online and available.
       *}
      TOX_USER_STATUS_NONE,

      {*
       * User is away. Clients can set this e.g. after a user defined
       * inactivity time.
       *}
      TOX_USER_STATUS_AWAY,

      {*
       * User is busy. Signals to other clients that this client does not
       * currently wish to communicate.
       *}
      TOX_USER_STATUS_BUSY
  );


  {**
   * Represents message types for tox_friend_send_message and group chat
   * messages.
   *}
  TOX_MESSAGE_TYPE =
  (
      {**
       * Normal text message. Similar to PRIVMSG on IRC.
      *}
      TOX_MESSAGE_TYPE_NORMAL,

      {**
       * A message describing an user action. This is similar to /me (CTCP ACTION)
       * on IRC.
      *}
      TOX_MESSAGE_TYPE_ACTION
  );

type
  {****************************************************************************
   *
   * :: Startup options
   *
   ****************************************************************************}

  {**
   * Type of proxy used to connect to TCP relays.
   *}
  TOX_PROXY_TYPE =
  (
      {**
       * Don't use a proxy.
       *}
      TOX_PROXY_TYPE_NONE,

      {**
       * HTTP proxy using CONNECT.
       *}
      TOX_PROXY_TYPE_HTTP,

      {**
       * SOCKS proxy for simple socket pipes.
       *}
      TOX_PROXY_TYPE_SOCKS5
  );

  {**
   * Type of savedata to create the Tox instance from.
   *}
  TOX_SAVEDATA_TYPE =
  (
      {**
       * No savedata.
       *}
      TOX_SAVEDATA_TYPE_NONE,

      {**
       * Savedata is one that was obtained from tox_get_savedata
       *}
      TOX_SAVEDATA_TYPE_TOX_SAVE,

      {**
       * Savedata is a secret key of length TOX_SECRET_KEY_SIZE
       *}
      TOX_SAVEDATA_TYPE_SECRET_KEY
  );

type
 {**
  * This struct contains all the startup options for Tox. You can either allocate
  * this object yourself, and pass it to tox_options_default, or call
  * tox_options_new to get a new default options object.
  *}
  Tox_Options = packed record
    ipv6, udp                  : cbool;
    proxy_type                 : TOX_PROXY_TYPE;
    proxy_host                 : pcchar;
    proxy_port, start_port,
     end_port, tcp_port        : cuint16;
    savedata_type              : TOX_SAVEDATA_TYPE;
    savedata_data              : pcuint8;
    savedata_length            : csize_t;
  end;

  PTox_Options = ^Tox_Options;

 {**
 * Initialises a Tox_Options object with the default options.
 *
 * The result of this function is independent of the original options. All
 * values will be overwritten, no values will be read (so it is permissible
 * to pass an uninitialised object).
 *
 * If options is NULL, this function has no effect.
 *
 * @param options An options object to be filled with default options.
 *}

procedure tox_options_default (options: PTox_Options); cdecl;
                                                       external LIBTOXCORE;
{**
 * Allocates a new Tox_Options object and initialises it with the default
 * options. This function can be used to preserve long term ABI compatibility by
 * giving the responsibility of allocation and deallocation to the Tox library.
 *
 * Objects returned from this function must be freed using the tox_options_free
 * function.
 *
 * @return A new Tox_Options object with default options or NULL on failure.
 *}
function tox_options_new(error: coff_t = 0) : PTox_Options; cdecl;
                                                            external LIBTOXCORE;
{**
 * Releases all resources associated with an options objects.
 *
 * Passing a pointer that was not returned by tox_options_new results in
 * undefined behaviour.
 *}
procedure tox_options_free(options: PTox_Options); cdecl; external LIBTOXCORE;

type
  {****************************************************************************
   *
   * :: Creation and destruction
   *
   ****************************************************************************}

  TOX_ERR_NEW =
  (
      TOX_ERR_NEW_OK,
      TOX_ERR_NEW_NULL,
      TOX_ERR_NEW_MALLOC,
      TOX_ERR_NEW_PORT_ALLOC,
      TOX_ERR_NEW_PROXY_BAD_TYPE,
      TOX_ERR_NEW_PROXY_BAD_HOST,
      TOX_ERR_NEW_PROXY_BAD_PORT,
      TOX_ERR_NEW_PROXY_NOT_FOUND,
      TOX_ERR_NEW_LOAD_ENCRYPTED,
      TOX_ERR_NEW_LOAD_BAD_FORMAT
  );

  PTOX_ERR_NEW = ^TOX_ERR_NEW;

{**
 * @brief Creates and initialises a new Tox instance with the options passed.
 *
 * This function will bring the instance into a valid state. Running the event
 * loop with a new instance will operate correctly.
 *
 * If loading failed or succeeded only partially, the new or partially loaded
 * instance is returned and an error code is set.
 *
 * @param options An options object as described above. If this parameter is
 *   NULL, the default options are used.
 *
 * @see tox_iterate for the event loop.
 *
 * @return A new Tox instance pointer on success or NULL on failure.
 *}
function tox_new(options: PTox_Options; error: PTOX_ERR_NEW) : TTox;
                                                            cdecl;
                                                            external LIBTOXCORE;

{**
 * Releases all resources associated with the Tox instance and disconnects from
 * the network.
 *
 * After calling this function, the Tox pointer becomes invalid. No other
 * functions can be called, and the pointer value can no longer be read.
 *}
procedure tox_kill(tox: TTox); cdecl; external LIBTOXCORE;

implementation

end.

