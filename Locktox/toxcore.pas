unit ToxCore;

{$macro on}
{$mode objfpc}{$H+}
{$DEFINE TOXFUNC:=cdecl; external LIBTOXCORE}

interface

uses
  Classes, SysUtils, ctypes;

const
  LIBTOXCORE = {$IFDEF Unix}'libtoxcore.so'{$ENDIF};

type
  TTox = Pointer;

const
 {*****************************************************************************
  *
  * :: Numeric constants
  *
  *****************************************************************************}

  {**
   * The size of a Tox Public Key in bytes.
   *}
  TOX_PUBLIC_KEY_SIZE                = 32;

  {**
   * The size of a Tox Secret Key in bytes.
   *}
  TOX_SECRET_KEY_SIZE                = 32;

  {**
   * The size of a Tox address in bytes. Tox addresses are in the format
   * [Public Key (TOX_PUBLIC_KEY_SIZE bytes)][nospam (4 bytes)][checksum (2 bytes)].
   *
   * The checksum is computed over the Public Key and the nospam value. The first
   * byte is an XOR of all the even bytes (0, 2, 4, ...), the second byte is an
   * XOR of all the odd bytes (1, 3, 5, ...) of the Public Key and nospam.
   *}
  TOX_ADDRESS_SIZE                     = (TOX_PUBLIC_KEY_SIZE +
                                         SizeOf(cuint32) + SizeOf(cuint16));
  {**
   * Maximum length of a nickname in bytes.
   *}
  TOX_MAX_NAME_LENGTH                  = 128;

  {**
   * Maximum length of a status message in bytes.
   *}
  TOX_MAX_STATUS_MESSAGE_LENGTH        = 1007;

  {**
   * Maximum length of a friend request message in bytes.
   *}
  TOX_MAX_FRIEND_REQUEST_LENGTH        = 1016;

  {**
   * Maximum length of a single message after which it should be split.
   *}
  TOX_MAX_MESSAGE_LENGTH               = 1372;

  {**
   * Maximum size of custom packets. TODO: should be LENGTH?
   *}
  TOX_MAX_CUSTOM_PACKET_SIZE           = 1373;

  {**
   * The number of bytes in a hash generated by tox_hash.
   *}
  TOX_HASH_LENGTH                      = 32;

  {**
   * The number of bytes in a file id.
   *}
  TOX_FILE_ID_LENGTH                   = 32;

  {**
   * Maximum file name length for file transfers.
   *}
  TOX_MAX_FILENAME_LENGTH              = 255;

type
  {****************************************************************************
   *
   * :: Global enumerations
   *
   ****************************************************************************}

  {**
   * Represents the possible statuses a client can have.
   *}
  TOX_USER_STATUS =
  (
      {**
       * User is online and available.
       *}
      TOX_USER_STATUS_NONE,

      {*
       * User is away. Clients can set this e.g. after a user defined
       * inactivity time.
       *}
      TOX_USER_STATUS_AWAY,

      {*
       * User is busy. Signals to other clients that this client does not
       * currently wish to communicate.
       *}
      TOX_USER_STATUS_BUSY
  );


  {**
   * Represents message types for tox_friend_send_message and group chat
   * messages.
   *}
  TOX_MESSAGE_TYPE =
  (
      {**
       * Normal text message. Similar to PRIVMSG on IRC.
      *}
      TOX_MESSAGE_TYPE_NORMAL,

      {**
       * A message describing an user action. This is similar to /me (CTCP ACTION)
       * on IRC.
      *}
      TOX_MESSAGE_TYPE_ACTION
  );

  {****************************************************************************
   *
   * :: Startup options
   *
   ****************************************************************************}

  {**
   * Type of proxy used to connect to TCP relays.
   *}
  TOX_PROXY_TYPE =
  (
      {**
       * Don't use a proxy.
       *}
      TOX_PROXY_TYPE_NONE,

      {**
       * HTTP proxy using CONNECT.
       *}
      TOX_PROXY_TYPE_HTTP,

      {**
       * SOCKS proxy for simple socket pipes.
       *}
      TOX_PROXY_TYPE_SOCKS5
  );

  {**
   * Type of savedata to create the Tox instance from.
   *}
  TOX_SAVEDATA_TYPE =
  (
      {**
       * No savedata.
       *}
      TOX_SAVEDATA_TYPE_NONE,

      {**
       * Savedata is one that was obtained from tox_get_savedata
       *}
      TOX_SAVEDATA_TYPE_TOX_SAVE,

      {**
       * Savedata is a secret key of length TOX_SECRET_KEY_SIZE
       *}
      TOX_SAVEDATA_TYPE_SECRET_KEY
  );

 {**
  * This struct contains all the startup options for Tox. You can either allocate
  * this object yourself, and pass it to tox_options_default, or call
  * tox_options_new to get a new default options object.
  *}
  Tox_Options = packed record
    ipv6, udp                  : cbool;
    proxy_type                 : TOX_PROXY_TYPE;
    proxy_host                 : pcchar;
    proxy_port, start_port,
     end_port, tcp_port        : cuint16;
    savedata_type              : TOX_SAVEDATA_TYPE;
    savedata_data              : pcuint8;
    savedata_length            : csize_t;
  end;
  PTox_Options = ^Tox_Options;

 {**
 * Initialises a Tox_Options object with the default options.
 *
 * The result of this function is independent of the original options. All
 * values will be overwritten, no values will be read (so it is permissible
 * to pass an uninitialised object).
 *
 * If options is NULL, this function has no effect.
 *
 * @param options An options object to be filled with default options.
 *}

procedure tox_options_default (options: PTox_Options); TOXFUNC;
{**
 * Allocates a new Tox_Options object and initialises it with the default
 * options. This function can be used to preserve long term ABI compatibility by
 * giving the responsibility of allocation and deallocation to the Tox library.
 *
 * Objects returned from this function must be freed using the tox_options_free
 * function.
 *
 * @return A new Tox_Options object with default options or NULL on failure.
 *}
function tox_options_new(error: coff_t = 0): PTox_Options; TOXFUNC;
{**
 * Releases all resources associated with an options objects.
 *
 * Passing a pointer that was not returned by tox_options_new results in
 * undefined behaviour.
 *}
procedure tox_options_free(options: PTox_Options); TOXFUNC;

type
  {****************************************************************************
   *
   * :: Creation and destruction
   *
   ****************************************************************************}

  TOX_ERR_NEW =
  (
      TOX_ERR_NEW_OK,
      TOX_ERR_NEW_NULL,
      TOX_ERR_NEW_MALLOC,
      TOX_ERR_NEW_PORT_ALLOC,
      TOX_ERR_NEW_PROXY_BAD_TYPE,
      TOX_ERR_NEW_PROXY_BAD_HOST,
      TOX_ERR_NEW_PROXY_BAD_PORT,
      TOX_ERR_NEW_PROXY_NOT_FOUND,
      TOX_ERR_NEW_LOAD_ENCRYPTED,
      TOX_ERR_NEW_LOAD_BAD_FORMAT
  );
  PTOX_ERR_NEW = ^TOX_ERR_NEW;

{**
 * @brief Creates and initialises a new Tox instance with the options passed.
 *
 * This function will bring the instance into a valid state. Running the event
 * loop with a new instance will operate correctly.
 *
 * If loading failed or succeeded only partially, the new or partially loaded
 * instance is returned and an error code is set.
 *
 * @param options An options object as described above. If this parameter is
 *   NULL, the default options are used.
 *
 * @see tox_iterate for the event loop.
 *
 * @return A new Tox instance pointer on success or NULL on failure.
 *}
function tox_new(options: PTox_Options; error: PTOX_ERR_NEW): TTox;
                                                            TOXFUNC;

{**
 * Releases all resources associated with the Tox instance and disconnects from
 * the network.
 *
 * After calling this function, the Tox pointer becomes invalid. No other
 * functions can be called, and the pointer value can no longer be read.
 *}
procedure tox_kill(tox: TTox); TOXFUNC;

{**
 * Calculates the number of bytes required to store the tox instance with
 * tox_get_savedata. This function cannot fail. The result is always greater
 * than 0.
 *
 * @see threading for concurrency implications.
 *}
function tox_get_savedata_size(tox: TTOX): csize_t; TOXFUNC;

{**
 * Store all information associated with the tox instance to a byte array.
 *
 * @param data A memory region large enough to store the tox instance data.
 *   Call tox_get_savedata_size to find the number of bytes required. If this
 *   parameter is NULL, this function has no effect.
 *}
procedure tox_get_savedata(tox: TTox; savedata: pcuint8); TOXFUNC;

{******************************************************************************
 *
 * :: Connection lifecycle and event loop
 *
 ******************************************************************************}

type
  TOX_ERR_BOOTSTRAP =
  (
      {**
       * The function returned successfully.
       *}
      TOX_ERR_BOOTSTRAP_OK,

      {**
       * One of the arguments to the function was NULL when it was not expected.
       *}
      TOX_ERR_BOOTSTRAP_NULL,

      {**
       * The address could not be resolved to an IP address, or the IP address
       * passed was invalid.
       *}
      TOX_ERR_BOOTSTRAP_BAD_HOST,

      {**
       * The port passed was invalid. The valid port range is (1, 65535).
       *}
      TOX_ERR_BOOTSTRAP_BAD_PORT
  );
  PTOX_ERR_BOOTSTRAP = ^TOX_ERR_BOOTSTRAP;

{**
 * Sends a "get nodes" request to the given bootstrap node with IP, port, and
 * public key to setup connections.
 *
 * This function will attempt to connect to the node using UDP. You must use
 * this function even if Tox_Options.udp_enabled was set to false.
 *
 * @param address The hostname or IP address (IPv4 or IPv6) of the node.
 * @param port The port on the host on which the bootstrap Tox instance is
 *   listening.
 * @param public_key The long term public key of the bootstrap node
 *   (TOX_PUBLIC_KEY_SIZE bytes).
 * @return true on success.
 *}
function tox_bootstrap(tox: TTox; address: pcchar; port: cuint16;
                       public_key: pcuint8; error: TOX_ERR_BOOTSTRAP): cbool;
                                                                       TOXFUNC;

{**
 * Adds additional host:port pair as TCP relay.
 *
 * This function can be used to initiate TCP connections to different ports on
 * the same bootstrap node, or to add TCP relays without using them as
 * bootstrap nodes.
 *
 * @param address The hostname or IP address (IPv4 or IPv6) of the TCP relay.
 * @param port The port on the host on which the TCP relay is listening.
 * @param public_key The long term public key of the TCP relay
 *   (TOX_PUBLIC_KEY_SIZE bytes).
 * @return true on success.
 *}
function tox_add_tcp_relay(tox: TTox; address: pcchar; port: cuint16;
                           public_key: pcuint8;
                           error: PTOX_ERR_BOOTSTRAP): cbool; TOXFUNC;

{**
 * Protocols that can be used to connect to the network or friends.
 *}
type
  TOX_CONNECTION =
  (
      {**
       * There is no connection. This instance, or the friend the state change is
       * about, is now offline.
       *}
      TOX_CONNECTION_NONE,

      {**
       * A TCP connection has been established. For the own instance, this means it
       * is connected through a TCP relay, only. For a friend, this means that the
       * connection to that particular friend goes through a TCP relay.
       *}
      TOX_CONNECTION_TCP,

      {**
       * A UDP connection has been established. For the own instance, this means it
       * is able to send UDP packets to DHT nodes, but may still be connected to
       * a TCP relay. For a friend, this means that the connection to that
       * particular friend was built using direct UDP packets.
       *}
      TOX_CONNECTION_UDP
  );

{**
 * Return whether we are connected to the DHT. The return value is equal to the
 * last value received through the `self_connection_status` callback.
 *}
function tox_self_get_connection_status(tox: TTox): TOX_CONNECTION; TOXFUNC;

{**
 * @param ConnectionStatus Whether we are connected to the DHT.
 *}
type
  TProcSelfConnectionStatus = procedure(Tox: TTox; ConnectionStatus: TOX_CONNECTION; UserData: Pointer); cdecl;

{**
 * Set the callback for the `self_connection_status` event. Pass NULL to unset.
 *
 * This event is triggered whenever there is a change in the DHT connection
 * state. When disconnected, a client may choose to call tox_bootstrap again, to
 * reconnect to the DHT. Note that this state may frequently change for short
 * amounts of time. Clients should therefore not immediately bootstrap on
 * receiving a disconnect.
 *
 * TODO: how long should a client wait before bootstrapping again?
 *}
procedure tox_callback_self_connection_status(tox: TTox; callback: TProcSelfConnectionStatus; user_data: Pointer); TOXFUNC;

{**
 * Return the time in milliseconds before tox_iterate() should be called again
 * for optimal performance.
 *}
function tox_iteration_interval(tox: TTox): cuint32; TOXFUNC;

{**
 * The main loop that needs to be run in intervals of tox_iteration_interval()
 * milliseconds.
 *}
procedure tox_iterate(tox: TTox); TOXFUNC;

{*******************************************************************************
 *
 * :: Internal client information (Tox address/id)
 *
 ******************************************************************************}

{**
 * Writes the Tox friend address of the client to a byte array. The address is
 * not in human-readable format. If a client wants to display the address,
 * formatting is required.
 *
 * @param address A memory region of at least TOX_ADDRESS_SIZE bytes. If this
 *   parameter is NULL, this function has no effect.
 * @see TOX_ADDRESS_SIZE for the address format.
 *}
procedure tox_self_get_address(tox: TTox; address: pcuint8); TOXFUNC;

{**
 * Set the 4-byte nospam part of the address.
 *
 * @param nospam Any 32 bit unsigned integer.
 *}
procedure tox_self_set_nospam(tox: TTox; nospam: cuint32); TOXFUNC;

{**
 * Get the 4-byte nospam part of the address.
 *}
function tox_self_get_nospam(tox: TTox): cuint32; TOXFUNC;

{**
 * Copy the Tox Public Key (long term) from the Tox object.
 *
 * @param public_key A memory region of at least TOX_PUBLIC_KEY_SIZE bytes. If
 *   this parameter is NULL, this function has no effect.
 *}
procedure tox_self_get_public_key(tox: TTox; public_key: pcuint8); TOXFUNC;

{**
 * Copy the Tox Secret Key from the Tox object.
 *
 * @param secret_key A memory region of at least TOX_SECRET_KEY_SIZE bytes. If
 *   this parameter is NULL, this function has no effect.
 *}
procedure tox_self_get_secret_key(tox: TTox; secret_key: pcuint8); TOXFUNC;

{*******************************************************************************
 *
 * :: User-visible client information (nickname/status)
 *
 ******************************************************************************}

type
  {**
   * Common error codes for all functions that set a piece of user-visible
   * client information.
   *}
  TOX_ERR_SET_INFO =
  (
      {**
       * The function returned successfully.
      *}
      TOX_ERR_SET_INFO_OK,

      {**
       * One of the arguments to the function was NULL when it was not expected.
      *}
      TOX_ERR_SET_INFO_NULL,

      {**
       * Information length exceeded maximum permissible size.
      *}
      TOX_ERR_SET_INFO_TOO_LONG
  );
  PTOX_ERR_SET_INFO = ^TOX_ERR_SET_INFO;

{**
 * Set the nickname for the Tox client.
 *
 * Nickname length cannot exceed TOX_MAX_NAME_LENGTH. If length is 0, the name
 * parameter is ignored (it can be NULL), and the nickname is set back to empty.
 *
 * @param name A byte array containing the new nickname.
 * @param length The size of the name byte array.
 *
 * @return true on success.
 *}
function tox_self_set_name(tox: TTox; name: pcuint8; length: csize_t;
                           error: PTOX_ERR_SET_INFO): cbool; TOXFUNC;

{**
 * Return the length of the current nickname as passed to tox_self_set_name.
 *
 * If no nickname was set before calling this function, the name is empty,
 * and this function returns 0.
 *
 * @see threading for concurrency implications.
 *}
function tox_self_get_name_size(tox: TTox): csize_t; TOXFUNC;

{**
 * Write the nickname set by tox_self_set_name to a byte array.
 *
 * If no nickname was set before calling this function, the name is empty,
 * and this function has no effect.
 *
 * Call tox_self_get_name_size to find out how much memory to allocate for
 * the result.
 *
 * @param name A valid memory location large enough to hold the nickname.
 *   If this parameter is NULL, the function has no effect.
 *}
procedure tox_self_get_name(tox: TTox; name: pcuint8); TOXFUNC;

{**
 * Set the client's status message.
 *
 * Status message length cannot exceed TOX_MAX_STATUS_MESSAGE_LENGTH. If
 * length is 0, the status parameter is ignored (it can be NULL), and the
 * user status is set back to empty.
 *}
function tox_self_set_status_message(tox: TTox; message: pcuint8;
                           length: csize_t;
                           error: PTOX_ERR_SET_INFO): cbool; TOXFUNC;

{**
 * Return the length of the current status message as passed to tox_self_set_status_message.
 *
 * If no status message was set before calling this function, the status
 * is empty, and this function returns 0.
 *
 * @see threading for concurrency implications.
 *}
function tox_self_get_status_message_size(tox: TTox): csize_t; TOXFUNC;

{**
 * Write the status message set by tox_self_set_status_message to a byte array.
 *
 * If no status message was set before calling this function, the status is
 * empty, and this function has no effect.
 *
 * Call tox_self_get_status_message_size to find out how much memory to allocate
 * for the result.
 *
 * @param status A valid memory location large enough to hold the status message.
 *   If this parameter is NULL, the function has no effect.
 *}
procedure tox_self_get_status_message(tox: TTox; status_message: pcuint8);
                                                                 TOXFUNC;

{**
 * Set the client's user status.
 *
 * @param user_status One of the user statuses listed in the enumeration above.
 *}
procedure tox_self_set_status(tox: TTox; status: TOX_USER_STATUS); TOXFUNC;

{**
 * Returns the client's user status.
 *}
function tox_self_get_status(tox: TTox): TOX_USER_STATUS; TOXFUNC;

implementation

end.

